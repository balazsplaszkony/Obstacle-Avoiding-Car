/*
 * speedcontrol.c
 *
 *  Created on: 2023. márc. 8.
 *      Author: plasz
 */

#include "motor.h"

Motor motor_left;
Motor motor_right;

void InitMotors(){

	//ennek igy lehet nem sok értelme van és máshogy kéne
	//motor_right.direction = STOP_M;
	motor_right.pwm_pin = BOARD_INITPINS_Motor1EN_PIN;
	motor_right.Input1 = BOARD_INITPINS_Motor1IN1_PIN;
	motor_right.Input2 = BOARD_INITPINS_Motor1IN2_PIN;

	//motor_left.direction = STOP_M;
	motor_left.pwm_pin = BOARD_INITPINS_Motor2EN_PIN;
	motor_left.Input1 = BOARD_INITPINS_Motor2IN1_PIN;
	motor_left.Input2 = BOARD_INITPINS_Motor2IN2_PIN;
}

void SetPWM_right(uint8_t duty){
	if(duty > MaximumDutyCycle)
		duty = MaximumDutyCycle;
	SCTIMER_UpdatePwmDutycycle(SCT0, 0U, duty, SCT0_pwmEvent[0]);
}


void SetPWM_left(uint8_t duty){
	if(duty > MaximumDutyCycle)
		duty = MaximumDutyCycle;
	SCTIMER_UpdatePwmDutycycle(SCT0, 1U, duty, SCT0_pwmEvent[0]);
}

void SetRPM(Motor* motor)
{
	//TODO
	;
}
void RotateForward(Motor* motor)
{
	  GPIO_PinWrite(GPIO, 0, motor->Input1, 1);
	  GPIO_PinWrite(GPIO, 0, motor->Input2, 0);

}
void RotateBackward(Motor* motor)
{
	  GPIO_PinWrite(GPIO, 0, motor->Input1, 0);
	  GPIO_PinWrite(GPIO, 0, motor->Input2, 1);
}

void StopMotors(Motor* motor)
{
	  GPIO_PinWrite(GPIO, 0, motor->Input1, 0);
	  GPIO_PinWrite(GPIO, 0, motor->Input2, 0);
}

void SCTIMERUpdatePwmDutycycle(SCT_Type *base, sctimer_out_t output, uint8_t dutyCyclePercent, uint32_t event)

{
    assert(dutyCyclePercent <= 100U);
    assert((uint32_t)output < (uint32_t)FSL_FEATURE_SCT_NUMBER_OF_OUTPUTS);
    assert(1U == (base->CONFIG & SCT_CONFIG_UNIFY_MASK));

    uint32_t periodMatchReg, pulseMatchReg;
    uint32_t pulsePeriod = 0, period;
    bool isHighTrue      = (0U != (base->OUT[output].CLR & (1UL << (event + 1U))));

    /* Retrieve the match register number for the PWM period */
    periodMatchReg = base->EV[event].CTRL & SCT_EV_CTRL_MATCHSEL_MASK;

    /* Retrieve the match register number for the PWM pulse period */
    pulseMatchReg = base->EV[event + 1U].CTRL & SCT_EV_CTRL_MATCHSEL_MASK;

    period = base->MATCH[periodMatchReg];

    /* Stop the counter before updating match register */
    SCTIMER_StopTimer(base, (uint32_t)kSCTIMER_Counter_U);

    /* For 100% dutycyle, make pulse period greater than period so the event will never occur */
    if (dutyCyclePercent >= 100U)
    {
        pulsePeriod = period + 2U;

        /* Set the initial output level base on output mode */
        if (isHighTrue)
        {
            base->OUTPUT |= (1UL << (uint32_t)output);
        }
        else
        {
            base->OUTPUT &= ~(1UL << (uint32_t)output);
        }
    }
    else
    {
        pulsePeriod = (uint32_t)(((uint64_t)period * dutyCyclePercent) / 100U);
    }

    /* Update dutycycle */
    base->MATCH[pulseMatchReg]    = pulsePeriod;
    base->MATCHREL[pulseMatchReg] = pulsePeriod;

    /* Restart the counter */
    SCTIMER_StartTimer(base, (uint32_t)kSCTIMER_Counter_U);
}


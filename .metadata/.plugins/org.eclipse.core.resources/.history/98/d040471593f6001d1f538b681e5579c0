/*
 * encoder.c
 *
 *  Created on: 2023. mÃ¡rc. 23.
 *      Author: plasz
 */

#include "encoder.h"

volatile uint32_t captured_time_right = 0;
volatile uint32_t captured_time_left = 0;
volatile uint32_t captured_time_right_prev = 0;
volatile uint32_t captured_time_left_prev = 0;
volatile double  microseconds_elapsed_right = 0;
volatile double microseconds_elapsed_left = 0;



volatile Encoder Encoder_right;
volatile Encoder Encoder_left;

void InitEncoders()
{
	Encoder_right.RPM = 0;
	Encoder_right.RPM_prev = 0;

	Encoder_left.RPM = 0;
	Encoder_left.RPM_prev = 0;
}


//void EncoderRightCallback(uint32_t flags) {
//
//	Encoder_right.RPM_prev= Encoder_right.RPM;
//	captured_time_right_prev = captured_time_right;
//	captured_time_right = CTIMER0->CR[1];
//	if(captured_time_right_prev)
//	{
//		microseconds_elapsed_right = captured_time_right - captured_time_right_prev;
//		Encoder_right.RPM = (1.0 / (microseconds_elapsed_right / (60.0 * 1000000.0))) * (1.0 / 20);
//	}
//
//	PRINTF("%d\n", (int)Encoder_right.RPM);
//}
//
//void EncoderLeftCallback(uint32_t flags) {
//	Encoder_left.RPM_prev= Encoder_left.RPM;
//
//	captured_time_left_prev = captured_time_left;
//	captured_time_left = CTIMER0->CR[2];
//	if(captured_time_left_prev)
//	{
//		microseconds_elapsed_left = captured_time_left - captured_time_left_prev;
//		Encoder_left.RPM = (1.0 / (microseconds_elapsed_left / (60.0 * 1000000.0))) * (1.0 / 20);
//	}
//	PRINTF("%d\n", (int)Encoder_left.RPM);
//}

float lowPassFilter(float input, float prevOutput, float deltaTime, float cutoffFreq)
{
    float RC = 1.0f / (2.0f * 3.14159 * cutoffFreq);
    float alpha = deltaTime / (RC + deltaTime);

    return alpha * input + (1.0f - alpha) * prevOutput;
}

void EncoderRightCallback(uint32_t flags) {
    static float filteredRPMRight = 0.0f;
    static float deltaTimeRight = 0.0f;

    Encoder_right.RPM_prev = Encoder_right.RPM;
    captured_time_right_prev = captured_time_right;
    captured_time_right = CTIMER0->CR[1];

    if (captured_time_right_prev) {
        microseconds_elapsed_right = captured_time_right - captured_time_right_prev;
        Encoder_right.RPM = (1.0 / (microseconds_elapsed_right / (60.0 * 1000000.0))) * (1.0 / Resolution);
    }

    deltaTimeRight = microseconds_elapsed_right / 1000000.0f;

    filteredRPMRight = Encoder_right.RPM;//lowPassFilter(Encoder_right.RPM, filteredRPMRight, deltaTimeRight, FILTER_CUTOFF_FREQ);

    //PRINTF("Right: %d\n", (int)filteredRPMRight);
}

void EncoderLeftCallback(uint32_t flags) {
    static float filteredRPMLeft = 0.0f;
    static float deltaTimeLeft = 0.0f;

    Encoder_left.RPM_prev = Encoder_left.RPM;
    captured_time_left_prev = captured_time_left;
    captured_time_left = CTIMER0->CR[2];

    if (captured_time_left_prev) {
        microseconds_elapsed_left = captured_time_left - captured_time_left_prev;
        Encoder_left.RPM = (1.0 / (microseconds_elapsed_left / (60.0 * 1000000.0))) * (1.0 / Resolution);
    }

    // Calculate time difference in seconds
    deltaTimeLeft = microseconds_elapsed_left / 1000000.0f;

    // Apply low-pass filter
    filteredRPMLeft =Encoder_left.RPM; //lowPassFilter(Encoder_left.RPM, filteredRPMLeft, deltaTimeLeft, FILTER_CUTOFF_FREQ);

    //PRINTF("Left: %d\n", (int)filteredRPMLeft);
}

/*
 * car.c
 *
 *  Created on: 2023. mÃ¡rc. 28.
 *      Author: plasz
 */


#include "car.h"
volatile UsartBuffer bluetooth_prompts;
Car car;
Car car_prev;

void InitComponents()
{
	InitUltrasonicMeasurement(&ultrasonic_measurement);
	InitOpticMeasurement(&optic_measurement);
	InitMotors();
	UsartBufferInit();
}

void InitCar()
{
	car.direction = STOPCAR;
	car.obstacle_avoidance = true;
	car.tempomat = false;

	car_prev.direction = STOPCAR;
	car_prev.obstacle_avoidance = true;
	car_prev.tempomat = false;

}

void ProcessPrompts()
{

	Car car_new = car;


	for(int i = 0; bluetooth_prompts.received_bytes; i++, bluetooth_prompts.received_bytes--){
	switch(bluetooth_prompts.buff[i])
		{
		case FORWARD: if(ultrasonic_measurement.distance_in_cm > 30)
						car_new.direction = GOFORWARD;
					  break;

		case BACKWARD: if(optic_measurement.back_left < TRESHOLD &&
						  optic_measurement.back_right < TRESHOLD)
						  car_new.direction = GOBACKWARD;

		case RIGHT: if(optic_measurement.front_right < TRESHOLD) car_new.direction = TURNRIGHT;
					break;

		case LEFT: if(optic_measurement.front_left < TRESHOLD) car_new.direction = TURNLEFT;
						break;

		case STOP: car_new.direction = STOPCAR; break;

		case TOGGLE_TEMPOMAT: car_new.tempomat = (!car.tempomat);
		}
}
	car_prev = car;
	car = car_new;


}

void UpdateDirection(){

	if(car.direction != car_prev.direction)
	{
		switch(car.direction)
		{
		case GOFORWARD: RotateForward(&motor_right); RotateForward(&motor_left); break;
		case GOBACKWARD: RotateBackward(&motor_right); RotateBackward(&motor_left); break;
		case TURNRIGHT: RotateForward(&motor_right); RotateBackward(&motor_left); break;
		case TURNLEFT: RotateBackward(&motor_right); RotateForward(&motor_left); break;
		case STOPCAR: StopMotors(&motor_right); StopMotors(&motor_left);break;
		default: break;
		}
	}
}

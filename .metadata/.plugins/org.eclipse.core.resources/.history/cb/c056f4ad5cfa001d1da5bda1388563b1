/*
 * encoder.c
 *
 *  Created on: 2023. mÃ¡rc. 23.
 *      Author: plasz
 */

#include "encoder.h"

volatile uint32_t captured_time_right = 0;
volatile uint32_t captured_time_left = 0;
volatile uint32_t captured_time_right_prev = 0;
volatile uint32_t captured_time_left_prev = 0;
volatile double  microseconds_elapsed_right = 0;
volatile double microseconds_elapsed_left = 0;



volatile Encoder Encoder_right;
volatile Encoder Encoder_left;

void InitEncoder(volatile Encoder* encoder) {
    encoder->RPM = 0.0f;
    encoder->RPM_prev = 0.0f;
    encoder->updated = false;
}



float lowPassFilter(float input, float prevOutput, float deltaTime, float cutoffFreq)
{
    float RC = 1.0f / (2.0f * 3.14159 * cutoffFreq);
    float alpha = deltaTime / (RC + deltaTime);

    return alpha * input + (1.0f - alpha) * prevOutput;
}



float butterworthSecondOrderLowPassFilter(float input, float* prevInputs, float* prevOutputs, float deltaTime)
{
    const float samplingFreq = 1.0f / deltaTime;
    const float omega = 2.0f * M_PI * FILTER_CUTOFF_FREQ;
    const float t = 1.0f / samplingFreq;
    const float c = 1.0f / (omega * omega * t * t + 2.0f * omega * t + 1.0f);
    const float a1 = 2.0f * (omega * omega * t * t - 1.0f) * c;
    const float a2 = (omega * omega * t * t - 2.0f * omega * t + 1.0f) * c;
    const float b0 = (omega * omega * t * t) * c;
    const float b1 = 2.0f * (omega * omega * t * t) * c;
    const float b2 = b0;
    const float output = b0 * input + b1 * prevInputs[0] + b2 * prevInputs[1] - a1 * prevOutputs[0] - a2 * prevOutputs[1];
    // Update history
    // Update history
    prevInputs[1] = prevInputs[0];
    prevInputs[0] = input;
    prevOutputs[1] = prevOutputs[0];
    prevOutputs[0] = output;

    return output;
}

int floatCompare(const void* a, const void* b) {
    float fa = *(const float*)a;
    float fb = *(const float*)b;
    return (fa > fb) - (fa < fb);
}

void EncoderRightCallback(uint32_t flags) {
    static float RPM_overshoot = 0;
    //static size_t measurementCount = 0;
    static bool overshoot_flag = false;
    static bool threshold = 0.1;
    // Store previous RPM and captured time
    //float RPM_prev = Encoder_right.RPM;
    uint32_t captured_time_right_prev = captured_time_right;

    // Update current RPM and captured time
    captured_time_right = CTIMER0->CR[1];
    if (captured_time_right_prev) {
        uint32_t microseconds_elapsed_right = captured_time_right - captured_time_right_prev;
        float new_RPM = (1.0 / (microseconds_elapsed_right / (60.0 * 1000000.0))) * (1.0 / Resolution);

        // Store current measurement
//        measurements[measurementCount] = new_RPM;
//        measurementCount = (measurementCount + 1) % NumOfMeasurements;
//
//        // Calculate the moving average
//        float sum = 0.0;
//        for (size_t i = 0; i < NumOfMeasurements; i++) {
//            sum += measurements[i];
//        }
//        float movingAverage = sum / NumOfMeasurements;
//
//        // Calculate the dynamic threshold as a percentage of the moving average
//        threshold = 0.1 * movingAverage;

        // Check if the new RPM is above the dynamic threshold
        if (fabs(new_RPM - Encoder_right.RPM) > threshold) {
            // Ignore the measurement and keep the previous RPM value
            //Encoder_right.RPM = RPM_prev;
        	overshoot_flag = true;
        	RPM_overshoot = new_RPM;
        } else {
            // Update the RPM with the valid measurement
            Encoder_right.RPM = new_RPM;
        }
    }

    // Set updated flag
    Encoder_right.updated = true;
}

void EncoderLeftCallback(uint32_t flags) {
    static float deltaTimeLeft = 0.0f;

    Encoder_left.RPM_prev = Encoder_left.RPM;
    captured_time_left_prev = captured_time_left;
    captured_time_left = CTIMER0->CR[2];

    if (captured_time_left_prev) {
        microseconds_elapsed_left = captured_time_left - captured_time_left_prev;
        Encoder_left.RPM = (1.0 / (microseconds_elapsed_left / (60.0 * 1000000.0))) * (1.0 / Resolution);
    }

    deltaTimeLeft = microseconds_elapsed_left / 1000000.0f;

    if(Encoder_left.RPM > MAX_RPM)
    	Encoder_left.RPM = MAX_RPM;
    //Encoder_left.RPM = lowPassFilter(Encoder_left.RPM, Encoder_left.RPM_prev, deltaTimeLeft, FILTER_CUTOFF_FREQ);

    Encoder_left.updated = true;
}

void HandleNoEncoderSignal(volatile Encoder* encoder)
{
	 // Reset RPM values to 0
	    encoder->RPM = 0.0f;
	    encoder->RPM_prev = 0.0f;

}

/*
 * encoder.c
 *
 *  Created on: 2023. mÃ¡rc. 23.
 *      Author: plasz
 */

#include "encoder.h"

volatile uint32_t captured_time_right = 0;
volatile uint32_t captured_time_left = 0;
volatile uint32_t captured_time_right_prev = 0;
volatile uint32_t captured_time_left_prev = 0;
volatile double  microseconds_elapsed_right = 0;
volatile double microseconds_elapsed_left = 0;



volatile Encoder Encoder_right;
volatile Encoder Encoder_left;

void InitEncoders()
{
	Encoder_right.RPM = 0;
	Encoder_right.RPM_prev = 0;
	Encoder_right.counter = 0;

	Encoder_left.RPM = 0;
	Encoder_left.RPM_prev = 0;
	Encoder_left.counter = 0;
}




float lowPassFilter(float input, float prevOutput, float deltaTime, float cutoffFreq)
{
    float RC = 1.0f / (2.0f * 3.14159 * cutoffFreq);
    float alpha = deltaTime / (RC + deltaTime);

    return alpha * input + (1.0f - alpha) * prevOutput;
}

void EncoderRightCallback(uint32_t flags) {
    static float filteredRPMRight = 0.0f;
    static float deltaTimeRight = 0.0f;

    Encoder_right.RPM_prev = Encoder_right.RPM;
    captured_time_right_prev = captured_time_right;
    captured_time_right = CTIMER0->CR[1];

    if (captured_time_right_prev) {
        microseconds_elapsed_right = captured_time_right - captured_time_right_prev;
        Encoder_right.RPM = (1.0 / (microseconds_elapsed_right / (60.0 * 1000000.0))) * (1.0 / Resolution);
    }

    deltaTimeRight = microseconds_elapsed_right / 1000000.0f;

    //filteredRPMRight = Encoder_right.RPM;
    filteredRPMRight = lowPassFilter(Encoder_right.RPM, filteredRPMRight, deltaTimeRight, FILTER_CUTOFF_FREQ);

    Encoder_right.counter++;
    //PRINTF("Right: %d\n", (int)filteredRPMRight);
}

void EncoderLeftCallback(uint32_t flags) {
    static float filteredRPMLeft = 0.0f;
    static float deltaTimeLeft = 0.0f;

    Encoder_left.RPM_prev = Encoder_left.RPM;
    captured_time_left_prev = captured_time_left;
    captured_time_left = CTIMER0->CR[2];

    if (captured_time_left_prev) {
        microseconds_elapsed_left = captured_time_left - captured_time_left_prev;
        Encoder_left.RPM = (1.0 / (microseconds_elapsed_left / (60.0 * 1000000.0))) * (1.0 / Resolution);
    }

    // Calculate time difference in seconds
    deltaTimeLeft = microseconds_elapsed_left / 1000000.0f;

    // Apply low-pass filter
    //filteredRPMLeft =Encoder_left.RPM;
    filteredRPMLeft = lowPassFilter(Encoder_left.RPM, filteredRPMLeft, deltaTimeLeft, FILTER_CUTOFF_FREQ);

    Encoder_left.counter++;
    //PRINTF("Left: %d\n", (int)filteredRPMLeft);
}
void EncoderTIMERHandler()
{
	static uint16_t ticks_left, ticks_right = 0;
	if(ticks_right == Encoder_right.counter){
		Encoder
	}

}

void HandleNoEncoderSignal(Encoder* encoder)
{

}

/*
 * encoder.c
 *
 *  Created on: 2023. mÃ¡rc. 23.
 *      Author: plasz
 */

#include "encoder.h"

volatile uint32_t captured_time_right = 0;
volatile uint32_t captured_time_left = 0;
volatile uint32_t captured_time_right_prev = 0;
volatile uint32_t captured_time_left_prev = 0;
volatile double  microseconds_elapsed_right = 0;
volatile double microseconds_elapsed_left = 0;



volatile Encoder Encoder_right;
volatile Encoder Encoder_left;

void InitEncoder(Encoder* encoder) {
    encoder->RPM = 0.0f;
    encoder->RPM_prev = 0.0f;
    encoder->prevInputs[0] = 0.0f;
    encoder->prevInputs[1] = 0.0f;
    encoder->prevOutputs[0] = 0.0f;
    encoder->prevOutputs[1] = 0.0f;
    encoder->counter = 0;
}



float lowPassFilter(float input, float prevOutput, float deltaTime, float cutoffFreq)
{
    float RC = 1.0f / (2.0f * 3.14159 * cutoffFreq);
    float alpha = deltaTime / (RC + deltaTime);

    return alpha * input + (1.0f - alpha) * prevOutput;
}



float butterworthSecondOrderLowPassFilter(float input, float* prevInputs, float* prevOutputs, float deltaTime)
{
    const float samplingFreq = 1.0f / deltaTime;
    const float omega = 2.0f * M_PI * FILTER_CUTOFF_FREQ;
    const float t = 1.0f / samplingFreq;
    const float c = 1.0f / (omega * omega * t * t + 2.0f * omega * t + 1.0f);
    const float a1 = 2.0f * (omega * omega * t * t - 1.0f) * c;
    const float a2 = (omega * omega * t * t - 2.0f * omega * t + 1.0f) * c;
    const float b0 = (omega * omega * t * t) * c;
    const float b1 = 2.0f * (omega * omega * t * t) * c;
    const float b2 = b0;
    const float output = b0 * input + b1 * prevInputs[0] + b2 * prevInputs[1] - a1 * prevOutputs[0] - a2 * prevOutputs[1];
    // Update history
    // Update history
    prevInputs[1] = prevInputs[0];
    prevInputs[0] = input;
    prevOutputs[1] = prevOutputs[0];
    prevOutputs[0] = output;

    return output;
}
void EncoderRightCallback(uint32_t flags) {
    static float filteredRPMRight = 0.0f;
    static float deltaTimeRight = 0.0f;

    Encoder_right.RPM_prev = Encoder_right.RPM;
    captured_time_right_prev = captured_time_right;
    captured_time_right = CTIMER0->CR[1];

    if (captured_time_right_prev) {
        microseconds_elapsed_right = captured_time_right - captured_time_right_prev;
        Encoder_right.RPM = (1.0 / (microseconds_elapsed_right / (60.0 * 1000000.0))) * (1.0 / Resolution);
    }

    deltaTimeRight = microseconds_elapsed_right / 1000000.0f;

    //filteredRPMRight = Encoder_right.RPM;
    filteredRPMRight = lowPassFilter(Encoder_right.RPM, filteredRPMRight, deltaTimeRight, FILTER_CUTOFF_FREQ);

    Encoder_right.counter++;
    //PRINTF("%d,\n", (int)filteredRPMRight);
}

void EncoderLeftCallback(uint32_t flags) {
    static float filteredRPMLeft = 0.0f;
    static float deltaTimeLeft = 0.0f;

    Encoder_left.RPM_prev = Encoder_left.RPM;
    captured_time_left_prev = captured_time_left;
    captured_time_left = CTIMER0->CR[2];

    if (captured_time_left_prev) {
        microseconds_elapsed_left = captured_time_left - captured_time_left_prev;
        Encoder_left.RPM = (1.0 / (microseconds_elapsed_left / (60.0 * 1000000.0))) * (1.0 / Resolution);
    }

    // Calculate time difference in seconds
    deltaTimeLeft = microseconds_elapsed_left / 1000000.0f;

    // Apply low-pass filter
    filteredRPMLeft =Encoder_left.RPM;
    //filteredRPMLeft = lowPassFilter(Encoder_left.RPM, filteredRPMLeft, deltaTimeLeft, FILTER_CUTOFF_FREQ);

    Encoder_left.counter++;
    //PRINTF("Left: %d\n", (int)filteredRPMLeft);
}
void EncoderTIMERHandler()
{
	static uint16_t ticks_left, ticks_right = 0;

	if(ticks_right == Encoder_right.counter)
		HandleNoEncoderSignal(&Encoder_right);

	if(ticks_left == Encoder_left.counter)
		HandleNoEncoderSignal(&Encoder_left);

	ticks_right = Encoder_right.counter;
	ticks_left = Encoder_left.counter;
}

void HandleNoEncoderSignal(volatile Encoder* encoder)
{
	encoder->RPM = 0;
	encoder->RPM_prev = 0;
}
